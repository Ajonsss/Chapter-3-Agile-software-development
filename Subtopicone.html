<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<style>
    :root {
        --primary-color: #EAE0C8;
        --secondary-color: #3B38A0;
        --tertiary-color: #1A2A80;

    }

    @font-face {
        font-family: 'PS';
        src: url(Product\ Sans\ Regular.ttf);
    }

    @font-face {
        font-family: 'PSB';
        src: url(Product\ Sans\ Bold.ttf);
    }

    @font-face {
        font-family: 'SFB';
        src: url(SFUIText-Heavy.otf);
    }

    body {
        background-color: var(--tertiary-color);
        font-family: 'PS';

    }

    main {
        color: var(--primary-color);
        padding-top: 100px;
        margin-left: 10%;
        margin-right: 10%;

        padding: 50px;
    }


    nav {
        text-align: center;
        position: fixed;
        top: 0;
        /* stick to top */
        left: 0;
        /* start from left edge */
        right: 0;
        /* stretch to right edge */
        background: #e8e8e831;
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(9px);
        -webkit-backdrop-filter: blur(9px);
        padding: 10px;
        margin: 0;
        overflow: hidden;
        width: 100%;
        /* make it responsive */
    }


    nav a {
        color: var(--primary-color);
        padding: 14px 20px;
        text-decoration: none;
        text-align: center;
        display: inline-block;
        font-size: 14px;
        transition: background-color 0.3s, color 0.3s;
        border-radius: 9px;
        border: 1px solid var(--primary-color);
    }

    nav a:hover {
        background: rgba(255, 255, 255, 0.1);
        /* translucent layer */
        color: var(--tertiary-color);
        backdrop-filter: blur(20px);
        /* iOS-style blur */
        -webkit-backdrop-filter: blur(20px);
        /* Safari support */
        border-radius: 9px;
    }

    h1 {
        font-size: 150px;
        padding: 10px;
        border-radius: 10px;
        max-width: fit-content;
        font-family: 'PSB';
        text-shadow: 5px 2px 4px #0000003c;
    }

    h2{
        padding-left: 10px;
    }

    h3{
        color: var(--primary-color);
        text-align: center;
    }

    .sectionism {
        background-color: var(--secondary-color);
        padding-left: 10px;
        padding-right: 10px;
        padding-top: 5px;
        padding-bottom: 5px;
        border-radius: 14px;
        max-width: fit-content;
        margin-bottom: 20px;
        box-shadow: 0 0 10px #0000003c;
    }



    p {
        background-color: var(--tertiary-color);
        padding: 10px;
        border-radius: 9px;
        max-width: fit-content;
        text-align: justify;
    }

    .figures {
        text-align: center;
        font-style: italic;
        font-size: 10px;
    }

    img {
        border-radius: 16px;
    }

    #footers {
        text-align: center;
        font-family: 'SFB';
        background-color: var(--secondary-color);
        color: var(--primary-color);
        font-size: x-small;
        margin-left: -8px;
        margin-right: -8px;
        margin-bottom: -8px;
    }
</style>



<body>
    <header>
        <nav>
            <a href="index.html">Home</a>
            <a href="Subtopicone.html">3.1 Agile methods</a>
            <a href="subtopictwo.html">3.2 Plan-driven and agile development</a>
            <a href="ExtremeProgramming.html">3.3 Extreme programming</a>
            <a href="Subtopicfour.html">3.4 Agile project management</a>
            <a href="Subtopicfive.html">3.5 Scaling agile methods</a>
        </nav>
    </header>

    <main>
        <Section>
            <h1>3.1 AGILE SOFTWARE DEVELOPMENT</h1>

            <Article class="sectionism">
                <h2>In the 1980s and early 1990s,</h2>
                <p>  there was a widespread view that the best way to
                    achieve better software was through careful project planning, formalized quality
                    assurance, the use of analysis and design methods supported by CASE tools, and
                    controlled and rigorous software development processes. This view came from the
                    software engineering community that was responsible for developing large, long
                    lived software systems such as aerospace and government systems.</p>

                <p> This software was developed by large teams working for different companies. Teams
                    were often geographically dispersed and worked on the software for long periods of
                    time. An example of this type of software is the control systems for a modern aircraft,
                    which might take up to 10 years from initial specification to deployment. These plan
                    driven approaches involve a significant overhead in planning, designing, and document
                    ing the system. This overhead is justified when the work of multiple development teams
                    has to be coordinated, when the system is a critical system, and when many different
                    people will be involved in maintaining the software over its lifetime.</p>

                <p> However, when this heavyweight, plan-driven development approach is applied
                    to small and medium-sized business systems, the overhead involved is so large that it
                    dominates the software development process. More time is spent on how the system
                    should be developed than on program development and testing. As the system
                    requirements change, rework is essential and, in principle at least, the specification
                    and design has to change with the program.</p>

            </Article>

            <Article class="sectionism">
                <h2>Dissatisfaction with these heavyweight approaches</h2>
                <p> to software engineering led a
                    number of software developers in the 1990s to propose new ‘agile methods’. These
                    allowed the development team to focus on the software itself rather than on its design and
                    documentation. Agile methods universally rely on an incremental approach to soft
                    ware specification, development, and delivery. They are best suited to application devel
                    opment where the system requirements usually change rapidly during the development
                    process. They are intended to deliver working software quickly to customers, who can
                    then propose new and changed requirements to be included in later iterations of the sys
                    tem. They aim to cut down on process bureaucracy by avoiding work that has dubious
                    long-term value and eliminating documentation that will probably never be used.
                    The philosophy behind agile methods is reflected in the agile manifesto that was
                    agreed on by many of the leading developers of these methods. This manifesto states:</p>

                <article>
                    <p> The authors are uncovering better ways of developing software by doing it and helping others do it.
                        Through
                        this work the authors have come to value:</p>

                    <ul>
                        <li>Individuals and interactions over processes and tools</li>
                        <li>Working software over comprehensive documentation</li>
                        <li>Customer collaboration over contract negotiation</li>
                        <li>Responding to change over following a plan</li>
                    </ul>

                    <p>That is, while there is value in the items on the right, the authors value the items on the left more.</p>

                </article>

            </Article>

            <h2>Extreme Programming</h2>
            <p> Probably the best-known agile method is extreme programming (Beck, 1999;
                Beck, 2000), which I describe later in this chapter. Other agile approaches include
                Scrum (Cohn, 2009; Schwaber, 2004; Schwaber and Beedle, 2001), Crystal
                (Cockburn, 2001; Cockburn, 2004), Adaptive Software Development (Highsmith,
                2000), DSDM (Stapleton, 1997; Stapleton, 2003), and Feature Driven Development
                (Palmer and Felsing, 2002). The success of these methods has led to some integration
                with more traditional development methods based on system modelling, resulting in
                the notion of agile modelling (Ambler and Jeffries, 2002) and agile instantiations of
                the Rational Unified Process (Larman, 2002).</p>

            <p> Although these agile methods are all based around the notion of incremental devel
                opment and delivery, they propose different processes to achieve this. However, they
                share a set of principles, based on the agile manifesto, and so have much in common.
                These principles are shown in Figure 3.1. Different agile methods instantiate these prin
                ciples in different ways and I don’t have space to discuss all agile methods. Instead, I
                focus on two of the most widely used methods: extreme programming (Section 3.3) and
                Scrum (Section 3.4).</p>

            <p>Agile methods have been very successful for some types of system development:</p>

            <ol>
                <li> Product development where a software company is developing a small or
                    medium-sized product for sale.</li>
                <li> Custom system development within an organization, where there is a clear com
                    mitment from the customer to become involved in the development process and
                    where there are not a lot of external rules and regulations that affect the software.
                </li>
            </ol>

        </Section>

        <section>
            <img src="f1.png" alt="Figure 3.1 The principles of agile methods">

            <p class="figures"> Figure 3.1 The principles of agile methods</p>

            <p>As the author discuss in the final section of this chapter, the success of agile methods has
                meant that there is a lot of interest in using these methods for other types of software
                development. However, because of their focus on small, tightly integrated teams,
                there are problems in scaling them to large systems. There have also been experi
                ments in using agile approaches for critical systems engineering (Drobna et al.,
                2004). However, because of the need for security, safety, and dependability analysis
                in critical systems, agile methods require significant modification before they can be
                routinely used for critical systems engineering.</p>

            <p>In practice, the principles underlying agile methods are sometimes difficult to realize:</p>

            <ol>
                <li>Although the idea of customer involvement in the development process is an
                    attractive one, its success depends on having a customer who is willing and able
                    to spend time with the development team and who can represent all system
                    stakeholders. Frequently, the customer representatives are subject to other pres
                    sures and cannot take full part in the software development.</li>
                <li>Individual team members may not have suitable personalities for the intense
                    involvement that is typical of agile methods, and therefore not interact well with
                    other team members.</li>
                <li>Prioritizing changes can be extremely difficult, especially in systems for which
                    there are many stakeholders. Typically, each stakeholder gives different priori
                    ties to different changes.</li>
                <li>Maintaining simplicity requires extra work. Under pressure from delivery
                    schedules, the team members may not have time to carry out desirable system
                    simplifications.</li>
                <li>Many organizations, especially large companies, have spent years changing
                    their culture so that processes are defined and followed. It is difficult for them to
                    move to a working model in which processes are informal and defined by devel
                    opment teams.</li>
            </ol>


            <article class="sectionism">
                <h2>Another non-technical problem</h2>
                <p>—that is a general problem with incremental
                    development and delivery—occurs when the system customer uses an outside organ
                    ization for system development. The software requirements document is usually part
                    of the contract between the customer and the supplier. Because incremental specifi
                    cation is inherent in agile methods, writing contracts for this type of development
                    may be difficult.</p>

                <p>Consequently, agile methods have to rely on contracts in which the customer pays
                    for the time required for system development rather than the development of a spe
                    cific set of requirements. So long as all goes well, this benefits both the customer and
                    the developer. However, if problems arise then there may be difficult disputes over
                    who is to blame and who should pay for the extra time and resources required to
                    resolve the problems.</p>

                <p> Most books and papers that describe agile methods and experiences with agile
                    methods talk about the use of these methods for new systems development.
                    However, as I explain in Chapter 9, a huge amount of software engineering effort
                    goes into the maintenance and evolution of existing software systems. There are only
                    a small number of experience reports on using agile methods for software mainte
                    nance (Poole and Huisman, 2001). There are two questions that should be consid
                    ered when considering agile methods and maintenance:</p>

                <ol>
                    <li>Are systems that are developed using an agile approach maintainable, given the emphasis in the
                        development process of minimizing formal documentation?</li>
                    <li>Can agile methods be used effectively for evolving a system in response to customer change
                        requests?
                    </li>
                </ol>

            </article>

            <article class="sectionism">
                <h2>Formal documentation</h2>
                <p> is supposed to describe the system and so make it easier
                    for people changing the system to understand. In practice, however, formal docu
                    mentation is often not kept up to date and so does not accurately reflect the program
                    code. For this reason, agile methods enthusiasts argue that it is a waste of time to
                    write this documentation and that the key to implementing maintainable software is
                    to produce high-quality, readable code. Agile practices therefore emphasize the
                    importance of writing well-structured code and investing effort in code improve
                    ment. Therefore, the lack of documentation should not be a problem in maintaining
                    systems developed using an agile approach.</p>

                <p> However, the author's experience of system maintenance suggests that the key document
                    is the system requirements document, which tells the software engineer what the
                    system is supposed to do. Without such knowledge, it is difficult to assess the impact
                    of proposed system changes. Many agile methods collect requirements informally
                    and incrementally and do not create a coherent requirements document. In this respect, the use of
                    agile
                    methods is likely to make subsequent system maintenance
                    more difficult and expensive.</p>


            </article>

            <article class="sectionism">
                <h2>Agile practices</h2>
                <p>used in the maintenance process itself, are likely to be effective,
                    whether or not an agile approach has been used for system development. Incremental
                    delivery, design for change and maintaining simplicity all make sense when software
                    is being changed. In fact, you can think of an agile development process as a process
                    of software evolution.</p>

                <p>However, the main difficulty after software delivery is likely to be keeping cus
                    tomers involved in the process. Although a customer may be able to justify the full
                    time involvement of a representative during system development, this is less likely
                    during maintenance where changes are not continuous. Customer representatives are
                    likely to lose interest in the system. Therefore, it is likely that alternative mecha
                    nisms, such as change proposals, discussed in Chapter 25, will be required to create
                    the new system requirements.</p>

                <p>The other problem that is likely to arise is maintaining continuity of the develop
                    ment team. Agile methods rely on team members understanding aspects of the
                    system without having to consult documentation. If an agile development team is
                    broken up, then this implicit knowledge is lost and it is difficult for new team mem
                    bers to build up the same understanding of the system and its components.</p>

                <p>Supporters of agile methods have been evangelical in promoting their use and
                    have tended to overlook their shortcomings. This has prompted an equally extreme
                    response, which, in the author's view, exaggerates the problems with this approach (Stephens
                    and Rosenberg, 2003). More reasoned critics such as DeMarco and Boehm
                    (DeMarco and Boehm, 2002) highlight both the advantages and disadvantages of
                    agile methods. They propose a hybrid approach where agile methods incorporate
                    some techniques from plan-driven development may be the best way forward.</p>
            </article>
        </section>


    </main>



    <footer id="footer">
        <p id="footers"> Copyright © 2011, 2006, 2005, 2001, 1996 Pearson Education, Inc., publishing as Addison-Wesley.
            All
            rights reserved. <br><br>

            Manufactured in the United States of America. This publication is protected by copyright,
            and permission should be obtained from the publisher prior to any prohibited reproduction, storage in a
            retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying,
            recording, or likewise. To obtain permission(s) to use material from this work, please submit a written
            request to Pearson Education, Inc., Permissions Department, 501 Boylston Street, Suite 900, Boston,
            Massachusetts 02116.</p>

            <h3>Created by: Andrae Ajon</h3>

    </footer>

</body>



</html>